{"mappings":"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","sources":["<anon>","src/bezier_curve_test.js"],"sourcesContent":["function main() {\n    const canvas = document.createElement('canvas');\n    canvas.width = 600;\n    canvas.height = 600;\n    document.body.appendChild(canvas);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    // Events\n    class Point {\n        constructor(x, y){\n            this.x = x;\n            this.y = y;\n        }\n    }\n    let isPressed = false;\n    let layers = [];\n    let currentPoints = [];\n    const POINT_SPAN = 1;\n    const APPLY_SPAN = 5;\n    const getPointByE = (e)=>{\n        const rect = e.target.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        return new Point(x, y);\n    };\n    canvas.addEventListener('contextmenu', (e)=>{\n        e.preventDefault();\n        currentPoints = [];\n        layers = [];\n    });\n    canvas.addEventListener('mousedown', (e)=>{\n        if (isPressed) return;\n        isPressed = true;\n        const point = getPointByE(e);\n        currentPoints = [\n            point,\n            point\n        ];\n        const layer = [\n            point,\n            point\n        ];\n        layers.push(layer);\n    });\n    canvas.addEventListener('mousemove', (e)=>{\n        if (!isPressed) return;\n        const point = getPointByE(e);\n        const lastPoint = currentPoints[currentPoints.length - 1];\n        if (Math.sqrt(Math.pow(point.y - lastPoint.y, 2) + Math.pow(point.x - lastPoint.x, 2)) >= POINT_SPAN) currentPoints.push(point);\n        const lastLayer = layers[layers.length - 1];\n        if (lastLayer.length > 0) {\n            const lastPoint = lastLayer[lastLayer.length - 1];\n            if (currentPoints.length >= APPLY_SPAN) {\n                currentPoints = [\n                    point\n                ];\n                lastLayer.push(point);\n            }\n        }\n    });\n    canvas.addEventListener('mouseup', (e)=>{\n        if (!isPressed) return;\n        isPressed = false;\n        const point = getPointByE(e);\n        currentPoints = [];\n        if (layers.length > 0) {\n            const lastLayer = layers[layers.length - 1];\n            if (lastLayer.length >= 3) {\n                lastLayer[lastLayer.length - 1].x = point.x;\n                lastLayer[lastLayer.length - 1].y = point.y;\n            } else lastLayer.push(point);\n        }\n    });\n    // Render\n    const render = ()=>{\n        // BG\n        ctx.fillStyle = '#000000';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Common\n        ctx.lineCap = 'round';\n        ctx.lineJoin = 'round';\n        // Current\n        ctx.strokeStyle = '#ffffff';\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        currentPoints.forEach((point, i)=>{\n            if (i === 0) ctx.moveTo(point.x, point.y);\n            else ctx.lineTo(point.x, point.y);\n        });\n        ctx.stroke();\n        ctx.closePath();\n        // Points\n        let cnt = 0;\n        layers.forEach((rawPoints)=>{\n            rawPoints.forEach((point)=>{\n                ctx.fillStyle = '#f00';\n                ctx.fillRect(point.x - 5, point.y - 5, 10, 10);\n                cnt++;\n            });\n        });\n        ctx.fillStyle = '#fff';\n        ctx.fillText(`${cnt}`, 10, 10);\n        // Curve\n        ctx.strokeStyle = '#fff';\n        ctx.lineWidth = 5;\n        layers.forEach((rawPoints)=>{\n            if (rawPoints.length === 0) return;\n            ctx.beginPath();\n            ctx.moveTo(rawPoints[0].x, rawPoints[0].y);\n            if (rawPoints.length === 2) ctx.lineTo(rawPoints[1].x, rawPoints[1].y);\n            else if (rawPoints.length > 2) {\n                let points = [\n                    ...rawPoints,\n                    rawPoints[rawPoints.length - 1]\n                ];\n                for(let i = 1; i < points.length - 2; i++){\n                    const p0 = points[i - 1];\n                    const p1 = points[i];\n                    const p2 = points[i + 1];\n                    const p3 = points[i + 2];\n                    const cp1x = p1.x + (p2.x - p0.x) / 6;\n                    const cp1y = p1.y + (p2.y - p0.y) / 6;\n                    const cp2x = p2.x - (p3.x - p1.x) / 6;\n                    const cp2y = p2.y - (p3.y - p1.y) / 6;\n                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);\n                }\n            }\n            ctx.stroke();\n            ctx.closePath();\n        });\n    };\n    render();\n    setInterval(()=>render(), 1000 / 15);\n}\nwindow.addEventListener('load', main);\n\n//# sourceMappingURL=bezier_curve_test.52c9827e.js.map\n","function main() {\n    const canvas = document.createElement('canvas')\n    canvas.width = 600\n    canvas.height = 600\n    document.body.appendChild(canvas)\n    const ctx = canvas.getContext('2d')\n    if (!ctx) {\n        return\n    }\n\n    // Events\n    class Point {\n        constructor(x, y) {\n            this.x = x\n            this.y = y\n        }\n    }\n    let isPressed = false\n    let layers = []\n    let currentPoints = []\n    const POINT_SPAN = 1\n    const APPLY_SPAN = 5\n    const getPointByE = (e) => {\n        const rect = e.target.getBoundingClientRect()\n        const x = e.clientX - rect.left\n        const y = e.clientY - rect.top\n        return new Point(x, y)\n    }\n    canvas.addEventListener('contextmenu', (e) => {\n        e.preventDefault()\n        currentPoints = []\n        layers = []\n    })\n    canvas.addEventListener('mousedown', (e) => {\n        if (isPressed) {\n            return\n        }\n        isPressed = true\n        const point = getPointByE(e)\n        currentPoints = [point, point]\n        const layer = [point, point]\n        layers.push(layer)\n    })\n    canvas.addEventListener('mousemove', (e) => {\n        if (!isPressed) {\n            return\n        }\n        const point = getPointByE(e)\n        const lastPoint = currentPoints[currentPoints.length - 1]\n        if (Math.sqrt(Math.pow(point.y - lastPoint.y, 2) + Math.pow(point.x - lastPoint.x, 2)) >= POINT_SPAN) {\n            currentPoints.push(point)\n        }\n        const lastLayer = layers[layers.length - 1]\n        if (lastLayer.length > 0) {\n            const lastPoint = lastLayer[lastLayer.length - 1]\n            if (currentPoints.length >= APPLY_SPAN) {\n                currentPoints = [point]\n                lastLayer.push(point)\n            }\n        }\n    })\n    canvas.addEventListener('mouseup', (e) => {\n        if (!isPressed) {\n            return\n        }\n        isPressed = false\n        const point = getPointByE(e)\n        currentPoints = []\n        if (layers.length > 0) {\n            const lastLayer = layers[layers.length - 1]\n            if (lastLayer.length >= 3) {\n                lastLayer[lastLayer.length - 1].x = point.x\n                lastLayer[lastLayer.length - 1].y = point.y\n            } else {\n                lastLayer.push(point)\n            }\n        }\n    })\n\n    // Render\n    const render = () => {\n        // BG\n        ctx.fillStyle = '#000000'\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\n        // Common\n        ctx.lineCap = 'round'\n        ctx.lineJoin = 'round'\n        // Current\n        ctx.strokeStyle = '#ffffff'\n        ctx.lineWidth = 2\n        ctx.beginPath()\n        currentPoints.forEach((point, i) => {\n            if (i === 0) {\n                ctx.moveTo(point.x, point.y)\n            } else {\n                ctx.lineTo(point.x, point.y)\n            }\n        })\n        ctx.stroke()\n        ctx.closePath()\n        // Points\n        let cnt = 0\n        layers.forEach((rawPoints) => {\n            rawPoints.forEach((point) => {\n                ctx.fillStyle = '#f00'\n                ctx.fillRect(point.x - 5, point.y - 5, 10, 10)\n                cnt++\n            })\n        })\n        ctx.fillStyle = '#fff'\n        ctx.fillText(`${cnt}`, 10, 10)\n        // Curve\n        ctx.strokeStyle = '#fff'\n        ctx.lineWidth = 5\n        layers.forEach((rawPoints) => {\n            if (rawPoints.length === 0) {\n                return\n            }\n            ctx.beginPath()\n            ctx.moveTo(rawPoints[0].x, rawPoints[0].y)\n            if (rawPoints.length === 2) {\n                ctx.lineTo(rawPoints[1].x, rawPoints[1].y)\n            } else if (rawPoints.length > 2) {\n                let points = [...rawPoints, rawPoints[rawPoints.length - 1]]\n                for (let i = 1; i < points.length - 2; i++) {\n                    const p0 = points[i - 1]\n                    const p1 = points[i]\n                    const p2 = points[i + 1]\n                    const p3 = points[i + 2]\n                    const cp1x = p1.x + (p2.x - p0.x) / 6\n                    const cp1y = p1.y + (p2.y - p0.y) / 6\n                    const cp2x = p2.x - (p3.x - p1.x) / 6\n                    const cp2y = p2.y - (p3.y - p1.y) / 6\n                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y)\n                }\n            }\n            ctx.stroke()\n            ctx.closePath()\n        })\n    }\n    render()\n    setInterval(() => render(), 1000 / 15)\n}\n\nwindow.addEventListener('load', main)\n"],"names":["main","canvas","document","createElement","width","height","body","appendChild","ctx","getContext","Point","constructor","x","y","isPressed","layers","currentPoints","getPointByE","e","rect","target","getBoundingClientRect","clientX","left","clientY","top","addEventListener","preventDefault","point","push","lastPoint","length","Math","sqrt","pow","lastLayer","render","fillStyle","fillRect","lineCap","lineJoin","strokeStyle","lineWidth","beginPath","forEach","i","moveTo","lineTo","stroke","closePath","cnt","rawPoints","fillText","points","p0","p1","p2","p3","cp1x","cp1y","cp2x","cp2y","bezierCurveTo","setInterval","window"],"version":3,"file":"bezier_curve_test.52c9827e.js.map"}