{"mappings":"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","sources":["<anon>","src/triangle_fill_test.ts"],"sourcesContent":["var $830202465d58529b$exports = {};\nclass $830202465d58529b$var$Vec2 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    // ベクトル同士の引き算\n    subtract(v) {\n        return new $830202465d58529b$var$Vec2(this.x - v.x, this.y - v.y);\n    }\n    // ベクトルの外積 (2D)\n    cross(v) {\n        return this.x * v.y - this.y * v.x;\n    }\n    // 点A, B, Cが時計回りか反時計回りかを判定\n    isClockwise(a, b, c) {\n        return b.subtract(a).cross(c.subtract(b)) < 0;\n    }\n}\n// ベクトル積を使って三角形の向きを確認（反時計回りか時計回りか）\nfunction $830202465d58529b$var$cross(a, b, o) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n// 耳の切り取り法で三角形を分割する関数\nfunction $830202465d58529b$var$triangulate(points) {\n    const triangles = [];\n    const vertices = [\n        ...points\n    ] // 元の点をコピー\n    ;\n    if ($830202465d58529b$var$isClockwise(vertices)) vertices.reverse();\n    while(vertices.length > 3){\n        let earFound = false;\n        for(let i = 0; i < vertices.length; i++){\n            const prev = vertices[(i - 1 + vertices.length) % vertices.length];\n            const curr = vertices[i];\n            const next = vertices[(i + 1) % vertices.length];\n            // 凸角かつ多角形の他の頂点が三角形に入らないかを確認\n            if ($830202465d58529b$var$isConvex(prev, curr, next) && $830202465d58529b$var$isEar(prev, curr, next, vertices)) {\n                // 三角形を切り取る\n                triangles.push([\n                    prev,\n                    curr,\n                    next\n                ]);\n                // 次のサイクルに向けて頂点を削除\n                vertices.splice(i, 1);\n                earFound = true;\n                break;\n            }\n        }\n        if (!earFound) throw new Error('Could not find an ear in the polygon. This might be due to an invalid or self-intersecting polygon.');\n    }\n    // 最後の三角形を追加\n    triangles.push([\n        vertices[0],\n        vertices[1],\n        vertices[2]\n    ]);\n    return triangles;\n}\n// 時計回りか反時計回りかを判定する関数\nfunction $830202465d58529b$var$isClockwise(vertices) {\n    let sum = 0;\n    for(let i = 0; i < vertices.length; i++){\n        const curr = vertices[i];\n        const next = vertices[(i + 1) % vertices.length];\n        sum += (next.x - curr.x) * (next.y + curr.y);\n    }\n    return sum > 0 // 正なら時計回り\n    ;\n}\n// 凸角かどうかを判定（反時計回りの多角形でも対応）\nfunction $830202465d58529b$var$isConvex(a, b, c) {\n    // 外積の符号が正ならば反時計回り（凸角）\n    return b.subtract(a).cross(c.subtract(b)) > 0;\n}\n// 三角形が有効かどうかを判定（耳の剪定法で使う）\nfunction $830202465d58529b$var$isEar(a, b, c, polygon) {\n    // 三角形内部に他の点が含まれていないか確認\n    for(let i = 0; i < polygon.length; i++){\n        const point = polygon[i];\n        if (point !== a && point !== b && point !== c && $830202465d58529b$var$isPointInTriangle(point, a, b, c)) return false;\n    }\n    return true;\n}\n// 点が三角形内にあるかどうかを確認する関数（バリューが0未満の場合、内部）\nfunction $830202465d58529b$var$isPointInTriangle(p, a, b, c) {\n    const cross1 = b.subtract(a).cross(p.subtract(a));\n    const cross2 = c.subtract(b).cross(p.subtract(b));\n    const cross3 = a.subtract(c).cross(p.subtract(c));\n    return cross1 >= 0 && cross2 >= 0 && cross3 >= 0;\n}\nfunction $830202465d58529b$var$main_func() {\n    const canvas = document.createElement('canvas');\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    document.body.appendChild(canvas);\n    let ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    window.addEventListener('resize', ()=>{\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        ctx = canvas.getContext('2d');\n    });\n    // Events\n    let isPressed = false;\n    const pointsList = [];\n    let currentPoints = [];\n    const trianglesList = [];\n    const drawSpan = 50;\n    canvas.addEventListener('mousedown', (e)=>{\n        if (isPressed) return;\n        isPressed = true;\n        const rect = e.target.getBoundingClientRect();\n        const point = new $830202465d58529b$var$Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        currentPoints = [\n            point\n        ];\n        pointsList.push(currentPoints);\n    });\n    canvas.addEventListener('mousemove', (e)=>{\n        if (!isPressed) return;\n        const rect = e.target.getBoundingClientRect();\n        const point = new $830202465d58529b$var$Vec2(e.clientX - rect.left, e.clientY - rect.top);\n        const lastPoint = currentPoints[currentPoints.length - 1];\n        if (lastPoint && Math.sqrt(Math.pow(point.y - lastPoint.y, 2) + Math.pow(point.x - lastPoint.x, 2)) > drawSpan) currentPoints.push(point);\n    });\n    canvas.addEventListener('mouseup', (e)=>{\n        if (!isPressed) return;\n        isPressed = false;\n        trianglesList.push($830202465d58529b$var$triangulate(currentPoints));\n    });\n    // Render\n    const render = ()=>{\n        if (!ctx) return;\n        // BG\n        ctx.fillStyle = '#000000';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        //\n        ctx.strokeStyle = '#ffffff';\n        ctx.strokeRect((canvas.width - 510) / 2, (canvas.height - 510) / 2, 510, 510);\n        ctx.strokeStyle = '#333333';\n        ctx.strokeRect(0, canvas.height / 2, canvas.width, 1);\n        ctx.strokeRect(canvas.width / 2, 0, 1, canvas.height);\n        //\n        trianglesList.forEach((tris, ts)=>{\n            tris.forEach((tri, t)=>{\n                if (!ctx) return;\n                ctx.fillStyle = `hsl(${Math.floor(t / tris.length * 360)}, 50%, 50%)`;\n                ctx.beginPath();\n                ctx.moveTo(tri[0].x, tri[0].y);\n                ctx.lineTo(tri[1].x, tri[1].y);\n                ctx.lineTo(tri[2].x, tri[2].y);\n                ctx.closePath();\n                ctx.fill();\n            });\n        });\n        //\n        pointsList.forEach((points, ps)=>{\n            if (!ctx) return;\n            ctx.strokeStyle = '#ffffff';\n            ctx.beginPath();\n            points.forEach((point, p)=>{\n                if (!ctx) return;\n                if (p === 0) ctx.moveTo(point.x, point.y);\n                else ctx.lineTo(point.x, point.y);\n            });\n            ctx.closePath();\n            ctx.stroke();\n        });\n    };\n    render();\n    setInterval(()=>render(), 1000 / 15);\n}\nwindow.addEventListener('load', $830202465d58529b$var$main_func);\n\n\n//# sourceMappingURL=triangle_fill_test.08ce60a1.js.map\n","class Vec2 {\n    x: number\n    y: number\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n    // ベクトル同士の引き算\n    subtract(v: Vec2) {\n        return new Vec2(this.x - v.x, this.y - v.y)\n    }\n    // ベクトルの外積 (2D)\n    cross(v: Vec2) {\n        return this.x * v.y - this.y * v.x\n    }\n    // 点A, B, Cが時計回りか反時計回りかを判定\n    isClockwise(a: Vec2, b: Vec2, c: Vec2) {\n        return b.subtract(a).cross(c.subtract(b)) < 0\n    }\n}\n\n// ベクトル積を使って三角形の向きを確認（反時計回りか時計回りか）\nfunction cross(a: Vec2, b: Vec2, o: Vec2) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)\n}\n\n// 耳の切り取り法で三角形を分割する関数\nfunction triangulate(points: Vec2[]) {\n    const triangles: Vec2[][] = []\n    const vertices = [...points] // 元の点をコピー\n\n    if (isClockwise(vertices)) {\n        vertices.reverse()\n    }\n\n    while (vertices.length > 3) {\n        let earFound = false\n        for (let i = 0; i < vertices.length; i++) {\n            const prev = vertices[(i - 1 + vertices.length) % vertices.length]\n            const curr = vertices[i]\n            const next = vertices[(i + 1) % vertices.length]\n\n            // 凸角かつ多角形の他の頂点が三角形に入らないかを確認\n            if (isConvex(prev, curr, next) && isEar(prev, curr, next, vertices)) {\n                // 三角形を切り取る\n                triangles.push([prev, curr, next])\n                // 次のサイクルに向けて頂点を削除\n                vertices.splice(i, 1)\n                earFound = true\n                break\n            }\n        }\n        if (!earFound) {\n            throw new Error('Could not find an ear in the polygon. This might be due to an invalid or self-intersecting polygon.')\n        }\n    }\n\n    // 最後の三角形を追加\n    triangles.push([vertices[0], vertices[1], vertices[2]])\n    return triangles\n}\n\n// 時計回りか反時計回りかを判定する関数\nfunction isClockwise(vertices: Vec2[]) {\n    let sum = 0\n    for (let i = 0; i < vertices.length; i++) {\n        const curr = vertices[i]\n        const next = vertices[(i + 1) % vertices.length]\n        sum += (next.x - curr.x) * (next.y + curr.y)\n    }\n    return sum > 0 // 正なら時計回り\n}\n\n// 凸角かどうかを判定（反時計回りの多角形でも対応）\nfunction isConvex(a: Vec2, b: Vec2, c: Vec2) {\n    // 外積の符号が正ならば反時計回り（凸角）\n    return b.subtract(a).cross(c.subtract(b)) > 0\n}\n\n// 三角形が有効かどうかを判定（耳の剪定法で使う）\nfunction isEar(a: Vec2, b: Vec2, c: Vec2, polygon: Vec2[]) {\n    // 三角形内部に他の点が含まれていないか確認\n    for (let i = 0; i < polygon.length; i++) {\n        const point = polygon[i]\n        if (point !== a && point !== b && point !== c && isPointInTriangle(point, a, b, c)) {\n            return false\n        }\n    }\n    return true\n}\n\n// 点が三角形内にあるかどうかを確認する関数（バリューが0未満の場合、内部）\nfunction isPointInTriangle(p: Vec2, a: Vec2, b: Vec2, c: Vec2) {\n    const cross1 = b.subtract(a).cross(p.subtract(a))\n    const cross2 = c.subtract(b).cross(p.subtract(b))\n    const cross3 = a.subtract(c).cross(p.subtract(c))\n    return cross1 >= 0 && cross2 >= 0 && cross3 >= 0\n}\n\nfunction main_func() {\n    const canvas = document.createElement('canvas')\n    canvas.width = window.innerWidth\n    canvas.height = window.innerHeight\n    document.body.appendChild(canvas)\n    let ctx = canvas.getContext('2d')\n    if (!ctx) {\n        return\n    }\n    window.addEventListener('resize', () => {\n        canvas.width = window.innerWidth\n        canvas.height = window.innerHeight\n        ctx = canvas.getContext('2d')\n    })\n\n    // Events\n    let isPressed = false\n    const pointsList: Vec2[][] = []\n    let currentPoints: Vec2[] = []\n    const trianglesList: Vec2[][][] = []\n    const drawSpan = 50\n    canvas.addEventListener('mousedown', (e) => {\n        if (isPressed) {\n            return\n        }\n        isPressed = true\n        const rect = (e.target as HTMLElement).getBoundingClientRect()\n        const point = new Vec2(e.clientX - rect.left, e.clientY - rect.top)\n        currentPoints = [point]\n        pointsList.push(currentPoints)\n    })\n    canvas.addEventListener('mousemove', (e) => {\n        if (!isPressed) {\n            return\n        }\n        const rect = (e.target as HTMLElement).getBoundingClientRect()\n        const point = new Vec2(e.clientX - rect.left, e.clientY - rect.top)\n        const lastPoint = currentPoints[currentPoints.length - 1]\n        if (lastPoint && Math.sqrt(Math.pow(point.y - lastPoint.y, 2) + Math.pow(point.x - lastPoint.x, 2)) > drawSpan) {\n            currentPoints.push(point)\n        }\n    })\n    canvas.addEventListener('mouseup', (e) => {\n        if (!isPressed) {\n            return\n        }\n        isPressed = false\n        trianglesList.push(triangulate(currentPoints))\n    })\n\n    // Render\n    const render = () => {\n        if (!ctx) {\n            return\n        }\n        // BG\n        ctx.fillStyle = '#000000'\n        ctx.fillRect(0, 0, canvas.width, canvas.height)\n        //\n        ctx.strokeStyle = '#ffffff'\n        ctx.strokeRect((canvas.width - 510) / 2, (canvas.height - 510) / 2, 510, 510)\n        ctx.strokeStyle = '#333333'\n        ctx.strokeRect(0, canvas.height / 2, canvas.width, 1)\n        ctx.strokeRect(canvas.width / 2, 0, 1, canvas.height)\n        //\n        trianglesList.forEach((tris, ts) => {\n            tris.forEach((tri, t) => {\n                if (!ctx) {\n                    return\n                }\n                ctx.fillStyle = `hsl(${Math.floor((t / tris.length) * 360)}, 50%, 50%)`\n                ctx.beginPath()\n                ctx.moveTo(tri[0].x, tri[0].y)\n                ctx.lineTo(tri[1].x, tri[1].y)\n                ctx.lineTo(tri[2].x, tri[2].y)\n                ctx.closePath()\n                ctx.fill()\n            })\n        })\n        //\n        pointsList.forEach((points, ps) => {\n            if (!ctx) {\n                return\n            }\n            ctx.strokeStyle = '#ffffff'\n            ctx.beginPath()\n            points.forEach((point, p) => {\n                if (!ctx) {\n                    return\n                }\n                if (p === 0) {\n                    ctx.moveTo(point.x, point.y)\n                } else {\n                    ctx.lineTo(point.x, point.y)\n                }\n            })\n            ctx.closePath()\n            ctx.stroke()\n        })\n    }\n    render()\n    setInterval(() => render(), 1000 / 15)\n}\n\nwindow.addEventListener('load', main_func)\n"],"names":["$830202465d58529b$var$Vec2","constructor","x","y","subtract","v","cross","isClockwise","a","b","c","window","addEventListener","canvas","document","createElement","width","innerWidth","height","innerHeight","body","appendChild","ctx","getContext","isPressed","pointsList","currentPoints","trianglesList","e","rect","target","getBoundingClientRect","clientX","left","clientY","top","push","point","lastPoint","length","Math","sqrt","pow","$830202465d58529b$var$triangulate","points","triangles","vertices","$830202465d58529b$var$isClockwise","sum","i","curr","next","reverse","earFound","prev","$830202465d58529b$var$isConvex","$830202465d58529b$var$isEar","polygon","$830202465d58529b$var$isPointInTriangle","p","cross1","cross2","cross3","splice","Error","render","fillStyle","fillRect","strokeStyle","strokeRect","forEach","tris","ts","tri","t","floor","beginPath","moveTo","lineTo","closePath","fill","ps","stroke","setInterval"],"version":3,"file":"triangle_fill_test.08ce60a1.js.map"}